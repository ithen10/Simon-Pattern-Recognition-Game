/*
 * SimonIanProject_5.c
 *
 * Created: 12/2/2018 6:01:46 PM
 * Author : Ian Then & Simon Salami
 * Description: This is a Simon pattern recognition game.
 *				The user is required to mimic the random pattern generated by the game.
 *				This pattern increases in length by 1 whenever the user succeeds to copy the game.
 *				At the end, whether win or lose, the game saves the high score achieved permanently.
 *				This means that even after resetting, the high score will be saved.
 */ 

/*Headers needed to be included*/
#include <ctype.h>
#include <avr/interrupt.h>
#include <stdint.h>
#include <stdbool.h>
#include <stdio.h>
#include "defines.h"
#include "hd44780.h"
#include "lcd.h"
#include <avr/io.h>
#include <util/delay.h>
#include <stdlib.h>
#include <avr/sleep.h>
#include <avr/eeprom.h>

#define num_8_address 0x00			//define address where values will be stored in and read from EEPROM

/*initialize volatile variables to be used in the interrupts, functions and main*/
volatile uint8_t Full_Sequence[150]={0} ;	//array for random numbers generated
volatile uint8_t receive[150]={0};		//array to hold user input
volatile int timer_count = 0;			//variable to count time
volatile uint8_t Simonturn=1;			//this indicates what turn the game is on
volatile uint8_t playerturn=1;			//this indicates what turn the player is on
volatile int label=0;				//this label is used to index the arrays
volatile bool playercorrect = 1;		//this bool variable is used to check if the player is still correct
volatile bool Simon_game = 1;			//this bool variable is used to check if the player is still in the current game
volatile uint8_t write_Hi_score = 1;		//this variable is to write into EEPROM
volatile uint8_t read_Hi_score;			//this variable is to read from EEPROM
volatile bool holding;
volatile bool variable;

/*function prototypes*/
void hardware_init();				//hardware initiation

/*these are for flashing the LEDs and sounding the buzzer when the game sends out a sequence*/
void Simon_blue();							
void Simon_red();
void Simon_yellow();
void Simon_green();

/*these are for flashing the LEDs and sounding the buzzer when the user presses a button*/
void User_blue();
void User_red();
void User_yellow();
void User_green();
void Simon_moves();				//the game shows its sequence during the game
void Simon_reads();				//the user tries to copy this sequence. the game reads the input
void check();					//check if user inputted sequence matches sequence
void compare_score();				//compare user score and high score
void clearlcd();				//clear the LCD
void printwakeup();				//print message to instruct user on how to wake game up
void printwelcome();				//print welcome message after waking up
void printroundstart();				//print "getting ready" message after the number is generated
void choose_randomseed();			//generate a random seed for random number generator
void startupflash();				//Sequence played when game wakes up
void fail_sequence();				//Sequence played when user input is wrong
void end_sequence();				//Sequence played when the game is going to sleep
void victory_sequence();			//Sequence played when the user wins
void all_led_on();				//Turn all LEDs on
void EEPROM_write(unsigned int uiAddress, uint8_t ucData); //function to write into EEPROM
int EEPROM_read(unsigned int uiAddress);	//function to read from EEPROM
void timeout();					//user times out 

FILE lcd_str = FDEV_SETUP_STREAM(lcd_putchar, NULL, _FDEV_SETUP_WRITE);	//initialize lcd_str as a stream

/*Timer1 Compare Match interrupt routine*/
ISR(TIMER1_COMPA_vect)	{			
	timer_count++;				//1 increment of variable = 1second
}

ISR(PCINT1_vect){				//Empty Pin Change interrupt routine to wake the game from sleep
}

int main(void){
	/*Hardware configurations*/
	hardware_init();
	//receive[0] = 7; 			//a value outside the range of 0 to 3
	
	while(1){				//game should never exit this while loop
		clearlcd();
		printwakeup(); 
		
		// prepare to go to Power Down mode
 		set_sleep_mode(SLEEP_MODE_PWR_DOWN);
 		cli();
 		sleep_enable();
 		sei();
 		sleep_cpu();			// go to sleep here to save power
 		sleep_disable();		// wake up when a button is pressed to start the game
		clearlcd();			//clear the LCD to display new information		startupflash();			// play the start up sequence for the game		printwelcome();			//play the welcome message after waking up
		choose_randomseed();		//generate a random seed for a random number generator
		printroundstart(); 		//prepare the user for the game to start
	
		for (int i = 0; i < 150 ; i++) //generate an array of random numbers
		{
			Full_Sequence[i] = rand() % 4;
		}

		Simon_game = 1;			//initialize variables for the game play
		Simonturn = 1;
		playerturn = 1;
			while (Simon_game)  	//this while loop keeps the game going until the user fails or the alloted time runs out
			{	
				while(playercorrect){//this while loop keeps the game going until the user fails
				   _delay_ms(500);
				  
					if (playerturn != 151){//game continues until user finishes the game
						Simon_moves(Simonturn);//displays the sequence of lights for the user to follow

						Simon_reads(playerturn);//reading, storing and checking the user's input
					} else{//victory sequence played when user finishes the full game
						clearlcd();
						victory_sequence();//display victory sequence
						clearlcd();
						playercorrect = 0;
						Simon_game=0;
					}
				}
			playercorrect = 1;
			Simon_game = 0;
			end_sequence();		//sequence is played before device goes to sleep
			
			
			}
	}
	}
/*function definitions*/

void hardware_init(){	/*Initializing the pins connected to the LEDs and Buttons*/
	stdout= &lcd_str;
	lcd_init();				//initialize LCD
	
	MCUCR &= ~(1<<PUD);			//enable all pull-ups
	
	PORTC |= (1<<PORTC5);			//set PC5 for LED1
	DDRC |= (1<<PORTC5);			//set PC5 to output
	PORTC |= (1<<PORTC4);			//set PC4 for SW1
	DDRC &= ~(1<<PORTC4);			//set PC4 to input
	
	PORTC |= (1<<PORTC3);			//set PC3 for LED2
	DDRC |= (1<<PORTC3);			//set PC3 to output
	PORTC |= (1<<PORTC2);			//set PC2 for SW2
	DDRC &= ~(1<<PORTC2);			//set PC2 to input
	
	PORTB |= (1<<PORTB6);			//set PB6 for LED3
	DDRB |= (1<<PORTB6);			//set PB6 to output
	PORTB |= (1<<PORTB7);			//set PB7 for SW3
	DDRB &= ~(1<<PORTB7);			//set PB7 to input
	
	PORTD |= (1<<PORTD7);			//set PD7 for LED4
	DDRD |= (1<<PORTD7);			//set PD7 to output
	PORTB |= (1<<PORTB0);			//set PB0 for SW4
	DDRB &= ~(1<<PORTB0);			//set PB0 to input
	
	PORTD &= ~(1<<PORTD5);			//buzzer pin initialization
	DDRD |= (1<<PORTD5);
	
	/*Initialize Phase Correct PWM for the buzzer*/
	OCR0B = 0;				//duty cycle of red LED starts at 0%
	OCR0A = 240;				//TOP is set to 240
	/*set the mode to non-inverting Phase Correct PWM with TOP=OCR0A and pre-scaler of 1*/
	TCCR0A |= (1<<COM0B1) | (0<<COM0B0) | (1<<WGM00);
	TCCR0B |= (1<<WGM02) | (1<<CS00);
	
	/*Initializing pin change interrupts*/
	PORTC |= (1<<PORTC0);			//set PC0 for Sleepdisable_Int
	DDRC &= ~(1<<PORTC0);			//set PC0 to input
	PCICR |= (1<<PCIE1);			//enable Group 1 interrupts
	PCMSK1 |= (1<<PCINT8);			//enable PCINT8 specifically
	/*initializing timer interrupts*/
	TIMSK1 |= (1<<OCIE1A); 			//enable output compare A match
	TCCR1B |= (1<<CS12) | (1<<WGM12) ;	//clock prescaler = /256, CTC mode, top value in OCR1A,clock = 1Mhz
	OCR1A = 3905;				//Time for 1 sec
	sei();
	TIMSK1 &= ~(1<<OCIE1A); 		//disable output compare A match}/*functions to flash LEDS and create tones when game displays a sequence*/
void Simon_blue(){
	OCR0A = 220; 				//topvalue
	OCR0B = 110;				//duty cycle of 50%
	PORTC &= ~(1<<PORTC5); 			//turn LED on
	_delay_ms(500);
	PORTC |= (1<<PORTC5);  			//turn LED off
	OCR0B = 0;				//duty cycle of 0%
	_delay_ms(50);
}
void Simon_red(){
	OCR0A = 230; 				//topvalue
	OCR0B = 115;				//duty cycle of 50%
	PORTC &= ~(1<<PORTC3); 			//turn LED on
	_delay_ms(500);
	PORTC |= (1<<PORTC3);  			//turn LED off
	OCR0B = 0;				//duty cycle of 0%
	_delay_ms(50);
}
void Simon_yellow(){
	OCR0A = 240; 				//topvalue
	OCR0B = 120;				//duty cycle of 50%
	PORTB &= ~(1<<PORTB6); 			//turn LED on
	_delay_ms(500);
	PORTB |= (1<<PORTB6);  			//turn LED off
	OCR0B = 0;				//duty cycle of 0%
	_delay_ms(50);
}
void Simon_green(){
	OCR0A = 250; 				//topvalue
	OCR0B = 125;				//duty cycle of 50%
	PORTD &= ~(1<<PORTD7); 			//turn LED on
	_delay_ms(500);
	PORTD |= (1<<PORTD7);  			//turn LED off
	OCR0B = 0;				//duty cycle of 0%
	_delay_ms(50);
}

/*functions to flash LEDS and create tones when user inputs a sequence*/
void User_blue(){
	OCR0A = 220; 				//topvalue
	OCR0B = 110;				//duty cycle of 50%
	PORTC &= ~(1<<PORTC5); 			//turn LED on
	_delay_ms(100);
	PORTC |= (1<<PORTC5);  			//turn LED off
	OCR0B = 0;				//duty cycle of 0%
}
void User_red(){
	OCR0A = 230; 				//topvalue
	OCR0B = 115;				//duty cycle of 50%
	PORTC &= ~(1<<PORTC3); 			//turn LED on
	_delay_ms(100);
	PORTC |= (1<<PORTC3);  			//turn LED off
	OCR0B = 0;				//duty cycle of 0%
}
void User_yellow(){
	OCR0A = 240; 				//topvalue
	OCR0B = 120;				//duty cycle of 50%
	PORTB &= ~(1<<PORTB6); 			//turn LED on
	_delay_ms(100);
	PORTB |= (1<<PORTB6);  			//turn LED off
	OCR0B = 0;				//duty cycle of 0%
}
void User_green(){
	OCR0A = 250; 				//topvalue
	OCR0B = 125;				//duty cycle of 50%
	PORTD &= ~(1<<PORTD7);			//turn LED on
	_delay_ms(100);
	PORTD |= (1<<PORTD7);  			//turn LED off
	OCR0B = 0;				//duty cycle of 0%	
}

/*function for the game to display the current sequence*/
void Simon_moves(){
	hd44780_outcmd(0x80);			//moving the cursor to the first location on the LCD
	hd44780_wait_ready(false);
	fprintf(stdout, "My turn    ");
	int i;
	for(i = 0 ; i < Simonturn ; i++){	//for loop to display the generated sequence element by element
		if(Full_Sequence[i] == 0){
			Simon_blue();
		} else if (Full_Sequence[i] == 1){
			Simon_red();
		} else if (Full_Sequence[i] == 2){
			Simon_yellow();
		} else if (Full_Sequence[i] == 3){
			Simon_green();
		}
		else {}
		
		}
	Simonturn++;				//increment the turn of the game by 1
	i=0;
	hd44780_outcmd(0x80);			//moving the cursor to the first location on the LCD
	hd44780_wait_ready(false);
	fprintf(stdout, "Your turn");
	}
	
/*function for the game to read the user's inputted the current sequence*/
void Simon_reads(){
	int j;
	label = 0;
	
	for(j = 0 ; j < playerturn ; j++){	//for loop to collect the user input
		TIMSK1 |= (1<<OCIE1A); 		//enable output compare A match
		timer_count = 0;		//reset the timer to start timing the user
		bool variable = 1;
		//bool pressed = 1;
		
		while(variable){
			if(timer_count != 5 && variable == 1){//if the count down is not over and the user hasn't failed, continue waiting for input
				if ((!(PINC & (1<<PINC4)))){ //if blue button is pressed
					while((!(PINC & (1<<PINC4)))){
						if ((timer_count == 5)){
							timeout();
							variable = 0;
							playercorrect = 0;
						}else{}
					}
					TIMSK1 &= ~(1<<OCIE1A); //disable output compare A match
					receive[label] = 0;
					check();	//check if it matches
					variable = 0;
					} else if ((!(PINC & (1<<PINC2)))){ //if red button is pressed
					while((!(PINC & (1<<PINC2)))){
						if ((timer_count == 5)){
							timeout();
							//compare_score(); //compare the user score to high score and store the high score
							variable = 0;
							//playerturn = 0;
							playercorrect = 0;
							}else{}
					}
					TIMSK1 &= ~(1<<OCIE1A); //disable output compare A match
					receive[label] = 1;
					check();
					variable = 0;
					} else if ((!(PINB & (1<<PINB7)))){ //if yellow button is pressed
					while((!(PINB & (1<<PINB7)))){
						if ((timer_count == 5)){
							timeout();
							//compare_score(); //compare the user score to high score and store the high score
							variable = 0;
							//playerturn = 0;
							playercorrect = 0;
							}else{}
					}
					TIMSK1 &= ~(1<<OCIE1A); //disable output compare A match
					receive[label] = 2;
					check();
					variable = 0;
					} else if ((!(PINB & (1<<PINB0)))){ //if green button is pressed
					while((!(PINB & (1<<PINB0)))){
						if ((timer_count == 5)){
							timeout();
							//compare_score(); //compare the user score to high score and store the high score
							variable = 0;
							//playerturn = 0;
							playercorrect = 0;
							}else{}
					}
					TIMSK1 &= ~(1<<OCIE1A); //disable output compare A match
					receive[label] = 3;
					check();
					variable = 0;
					} else{}
					}else{ //if the time is up, display the right sequence, compare the user score with high score and save the high score
						timeout();
						compare_score();
						variable = 0;
						playerturn = 0;
						playercorrect = 0;
						
					}
			}
	label++;
		}
		playerturn++;
		
}
			
	
void check(){					//check the user input with the right option
		if(receive[label] == Full_Sequence[label]){ //success
			if(receive[label] == 0){
				User_blue();
			} else if (receive[label] == 1){
				User_red();
			} else if (receive[label] == 2){
				User_yellow();
			} else if (receive[label] == 3){
				User_green();
			} else {}
		}else{	//if the user input is wrong, display the right option
			if(Full_Sequence[label] == 0){	//correct LED is blue, flash 3 times
			_delay_ms(500);
			User_blue();
			_delay_ms(100);
			User_blue();
			_delay_ms(100);
			User_blue();
			_delay_ms(100);
			} else if (Full_Sequence[label] == 1){	//correct LED is red, flash 3 times
			_delay_ms(500);
			User_red();
			_delay_ms(100);
			User_red();
			_delay_ms(100);
			User_red();
			_delay_ms(100);
			} else if (Full_Sequence[label] == 2){	//correct LED is yellow, flash 3 times
			_delay_ms(500);	
			User_yellow();
			_delay_ms(100);
			User_yellow();
			_delay_ms(100);
			User_yellow();
			_delay_ms(100);
			} else if (Full_Sequence[label] == 3){	//correct LED is green, flash 3 times
			_delay_ms(500);
			User_green();
			_delay_ms(100);
			User_green();
			_delay_ms(100);
			User_green();
			_delay_ms(100);
			} else {}		//else do nothing
					
		_delay_ms(100);	
		fail_sequence();		//play the fail sequence
		compare_score();		//compare the user score to high score and store the high score					
		playercorrect = 0;		//to get out of while loop in main
		playerturn = 0;			//to get out of for loop	
			}
}

void compare_score(){				//compare saved high score with user score and stores the max score
	int High_score;				//initialize this variable to save EEPROM data into RAM for comparing
	cli();		
	High_score = EEPROM_read(num_8_address);//read saved high score from EEPROM
	sei();
	
	if((playerturn-1) >= High_score){	//compare player's score with high score that was saved in EEPROM
		cli();
		EEPROM_write(num_8_address, playerturn-1);
		sei();
		hd44780_outcmd(0x80);		//moving the cursor to the first location on the LCD
		hd44780_wait_ready(false);
		fprintf(stdout, "Your Score: %u", playerturn-1);
		hd44780_outcmd(0xc0);		//moving the cursor to the first location on the LCD
		hd44780_wait_ready(false);
		fprintf(stdout, "High Score: %u", playerturn-1);
		TIMSK1 |= (1<<OCIE1A); 		//enable output compare A match
		timer_count = 0;
		while(timer_count != 3){}
		TIMSK1 &= ~(1<<OCIE1A); 	//disable output compare A match	
	} else{
		hd44780_outcmd(0x80);		//moving the cursor to the first location on the LCD
		hd44780_wait_ready(false);
		fprintf(stdout, "Your Score: %u", playerturn-1);
		hd44780_outcmd(0xc0);		//moving the cursor to the first location on the LCD
		hd44780_wait_ready(false);
		fprintf(stdout, "High Score: %d", High_score);
		TIMSK1 |= (1<<OCIE1A); 		//enable output compare A match
		timer_count = 0;
		while(timer_count != 2){}
		TIMSK1 &= ~(1<<OCIE1A); 	//disable output compare A match
		}
}

void EEPROM_write(unsigned int uiAddress, unsigned char ucData)	//writing to EEPROM
{
	/* Wait for completion of previous write */
	while(EECR & (1<<EEPE))
	;
	/* Set up address and Data Registers */
	EEAR = uiAddress;
	EEDR = ucData;
	/* Write logical one to EEMPE */
	EECR |= (1<<EEMPE);
	/* Start eeprom write by setting EEPE */
	EECR |= (1<<EEPE);
}

int EEPROM_read(unsigned int uiAddress)	//reading from EEPROM
{
	/* Wait for completion of previous write */
	while(EECR & (1<<EEPE)){}
	
	/* Set up address register */
	EEAR = uiAddress;
	/* Start eeprom read by writing EERE */
	EECR |= (1<<EERE);
	/* Return data from Data Register */
	return EEDR ;
}void clearlcd(){	hd44780_outcmd(0x80);			//moving the cursor to the first location on the LCD
	hd44780_wait_ready(false);
	fprintf(stdout, "                ");
	hd44780_outcmd(0xc0);			//moving the cursor to the first location on the LCD
	hd44780_wait_ready(false);
	fprintf(stdout, "                ");}void printwelcome(){	
	hd44780_outcmd(0x80);			//moving the cursor to the first location on the LCD
	hd44780_wait_ready(false);
	fprintf(stdout, "Welcome!");
	hd44780_outcmd(0xc0);			//moving the cursor to the first location on the LCD
	hd44780_wait_ready(false);
	fprintf(stdout, "If you're ready");
	TIMSK1 |= (1<<OCIE1A); 			//enable output compare A match
	timer_count = 0;
	while(timer_count != 3){}
	TIMSK1 &= ~(1<<OCIE1A); 		//disable output compare A match
	clearlcd();
	
	hd44780_outcmd(0x80);			//moving the cursor to the first location on the LCD
	hd44780_wait_ready(false);
	fprintf(stdout, "press one of the");
	hd44780_outcmd(0xc0);			//moving the cursor to the first location on the LCD
	hd44780_wait_ready(false);
	fprintf(stdout, "4 buttons below");	TIMSK1 |= (1<<OCIE1A); 			//enable output compare A match
	timer_count = 0;
	while(timer_count != 1){}	TIMSK1 &= ~(1<<OCIE1A); 		//disable output compare A match	}void printroundstart(){	clearlcd();	hd44780_outcmd(0x80);			//moving the cursor to the first location on the LCD
	hd44780_wait_ready(false);
	fprintf(stdout, "Goal: Repeat ");	hd44780_outcmd(0xc0);			//moving the cursor to the first location on the LCD
	hd44780_wait_ready(false);	fprintf(stdout, "the sequence" );	TIMSK1 |= (1<<OCIE1A);			//enable output compare A match
	timer_count = 0;
	while(timer_count != 3){}
	TIMSK1 &= ~(1<<OCIE1A);			//disable output compare A match
	clearlcd();		hd44780_outcmd(0x80);			//moving the cursor to the first location on the LCD
	hd44780_wait_ready(false);
	fprintf(stdout, "You have 5 secs ");
	hd44780_outcmd(0xc0);			//moving the cursor to the first location on the LCD
	hd44780_wait_ready(false);
	fprintf(stdout, "for each move ");
	TIMSK1 |= (1<<OCIE1A);			//enable output compare A match
	timer_count = 0;
	while(timer_count != 3){}
	TIMSK1 &= ~(1<<OCIE1A);			//disable output compare A match
	clearlcd();		hd44780_outcmd(0x80);			//moving the cursor to the first location on the LCD
	hd44780_wait_ready(false);
	fprintf(stdout, "High Score: %d", EEPROM_read(num_8_address));
	TIMSK1 |= (1<<OCIE1A);			//enable output compare A match
	timer_count = 0;
	while(timer_count != 3){}
	TIMSK1 &= ~(1<<OCIE1A);			//disable output compare A match
	clearlcd();
	
	hd44780_outcmd(0x80);			//moving the cursor to the first location on the LCD
	hd44780_wait_ready(false);
	fprintf(stdout, "Here we go!");
	hd44780_outcmd(0xc0);			//moving the cursor to the first location on the LCD
	hd44780_wait_ready(false);
	fprintf(stdout, "Good luck!");
	TIMSK1 |= (1<<OCIE1A);			//enable output compare A match
	timer_count = 0;
	while(timer_count != 2){}
	TIMSK1 &= ~(1<<OCIE1A);			//disable output compare A match	clearlcd();}void choose_randomseed(){			//uses the clock valve and other data to generate a random seed	bool randomseed = 1;			//this variable is a condition for the while loop below, once the seed is generated, randomseed=0
	while(randomseed){
		if ((!(PINC & (1<<PINC4)))){	//if blue button is pressed
			while((!(PINC & (1<<PINC4)))){}
			User_blue();	
			srand(2*TCNT1 + PINC);	//use this seed
			randomseed=0;
			} else if ((!(PINC & (1<<PINC2)))){	//if red button is pressed
			while((!(PINC & (1<<PINC2)))){}
			User_red();
			srand(3*TCNT1 + PINC);	//use this seed
			randomseed=0;
			} else if ((!(PINB & (1<<PINB7)))){	//if yellow button is pressed
			while((!(PINB & (1<<PINB7)))){}
			User_yellow();
			srand(4*TCNT1 + PINB);	//use this seed
			randomseed=0;
			} else if ((!(PINB & (1<<PINB0)))){	//if green button is pressed
			while((!(PINB & (1<<PINB0)))){}
			User_green();
			srand(5*TCNT1 + PINB);	//use this seed
			randomseed=0;
			} else{}
		}}void startupflash(){				//startup light sequence	User_green();	User_yellow();	User_red();	User_blue();}void fail_sequence(){				//fail sequence	hd44780_outcmd(0x80);			//moving the cursor to the first location on the LCD
	hd44780_wait_ready(false);
	fprintf(stdout, "Wrong move!     ");	User_blue();	_delay_ms(50);	User_red();	_delay_ms(50);	User_yellow();	_delay_ms(50);	User_green();	_delay_ms(50);	clearlcd();}void end_sequence(){				//sequence before MCU sleeps	hd44780_outcmd(0x80);			//moving the cursor to the first location on the LCD
	hd44780_wait_ready(false);
	fprintf(stdout, "Thanks for      ");
	hd44780_outcmd(0xc0);			//moving the cursor to the first location on the LCD
	hd44780_wait_ready(false);
	fprintf(stdout, "playing!        ");
	TIMSK1 |= (1<<OCIE1A);			//enable output compare A match
	timer_count = 0;
	while(timer_count != 2){}	TIMSK1 &= ~(1<<OCIE1A);			//disable output compare A match
	
	hd44780_outcmd(0x80);			//moving the cursor to the first location on the LCD
	hd44780_wait_ready(false);
	fprintf(stdout, "I'm going to    ");
	hd44780_outcmd(0xc0);			//moving the cursor to the first location on the LCD
	hd44780_wait_ready(false);
	fprintf(stdout, "sleep. G'night! ");
	Simon_green();
	Simon_blue();
	User_red();
	User_yellow();
	Simon_green();}void victory_sequence(){			//sequence displayed when the user beats the game	all_led_on();	compare_score();	hd44780_outcmd(0x80);			//moving the cursor to the first location on the LCD
	hd44780_wait_ready(false);
	fprintf(stdout, "You won!!       ");
	hd44780_outcmd(0xc0);			//moving the cursor to the first location on the LCD
	hd44780_wait_ready(false);
	fprintf(stdout, "Congratulations!");
	TIMSK1 |= (1<<OCIE1A); //enable output compare A match
	timer_count = 0;
	while(timer_count != 2){}	TIMSK1 &= ~(1<<OCIE1A); //disable output compare A match}void all_led_on(){				//this function blinks the LEDs	OCR0A = 200;				//top value
	OCR0B = 100;				//duty cycle of 50%	PORTC &= ~(1<<PORTC5);
	PORTC &= ~(1<<PORTC3);
	PORTB &= ~(1<<PORTB6);
	PORTD &= ~(1<<PORTD7);
	_delay_ms(300);
	
	OCR0B = 0;				//turn off buzzer
	PORTC |= (1<<PORTC5);			//turn off LEDs	PORTC |= (1<<PORTC3);
	PORTB |= (1<<PORTB6);
	PORTD |= (1<<PORTD7);	_delay_ms(200);		OCR0A = 200;				//top value
	OCR0B = 100;				//duty cycle of 50%	PORTC &= ~(1<<PORTC5);
	PORTC &= ~(1<<PORTC3);
	PORTB &= ~(1<<PORTB6);
	PORTD &= ~(1<<PORTD7);
	_delay_ms(300);
	
	OCR0B = 0;				//turn off buzzer
	PORTC |= (1<<PORTC5);			//turn off LEDs	PORTC |= (1<<PORTC3);
	PORTB |= (1<<PORTB6);
	PORTD |= (1<<PORTD7);	_delay_ms(200);		OCR0A = 200;				//topvalue
	OCR0B = 100;				//duty cycle of 50%	PORTC &= ~(1<<PORTC5);
	PORTC &= ~(1<<PORTC3);
	PORTB &= ~(1<<PORTB6);
	PORTD &= ~(1<<PORTD7);
	_delay_ms(300);
	
	OCR0B = 0;				//turn off buzzer
	PORTC |= (1<<PORTC5);			//turn off LEDs	PORTC |= (1<<PORTC3);
	PORTB |= (1<<PORTB6);
	PORTD |= (1<<PORTD7);	_delay_ms(200);}void printwakeup(){				//message displayed at start up		hd44780_outcmd(0x80);		//moving the cursor to the first location on the LCD
		hd44780_wait_ready(false);
		fprintf(stdout, "Press button -->");
		hd44780_outcmd(0xc0);		//moving the cursor to the first location on the LCD
		hd44780_wait_ready(false);
		fprintf(stdout, "to wake me up");}void timeout(){	hd44780_outcmd(0x80);			//moving the cursor to the first location on the LCD
	hd44780_wait_ready(false);
	fprintf(stdout, "Time is up!");
	if(Full_Sequence[label] == 0){
		Simon_blue();
		Simon_blue();
		Simon_blue();
		} else if (Full_Sequence[label] == 1){
		Simon_red();
		Simon_red();
		Simon_red();
		} else if (Full_Sequence[label] == 2){
		Simon_yellow();
		Simon_yellow();
		Simon_yellow();
		} else if (Full_Sequence[label] == 3){
		Simon_green();
		Simon_green();
		Simon_green();
		} else {}	User_blue();	_delay_ms(50);	User_red();	_delay_ms(50);	User_yellow();	_delay_ms(50);	User_green();	_delay_ms(50);}		